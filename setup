#!/bin/bash

# we will be dealing with lots of .files, reduce risk of missing some
shopt -s dotglob

function die # message
{
    echo "$@"
    exit 1
}

function usage
{
    echo "usage: $(basename $0) [<flags>]"
    echo "Sets up barrkel in home ($(cd ~; pwd))"
    echo "flags:"
    echo "  -q  Don't prompt on startup"
    echo "  -c  Continue even if cached config is different"
    echo "  -f  Overwrite existing files when applying staged home directory"
    exit 1
}

function maybe_echo_dir # dir...
{
    local dir
    for dir; do
        test -d "$dir" && echo "$dir"
    done
}

function get_atom_dirs
{
    maybe_echo_dir "$barrkel/host/$hostname"
    test -f "$barrkel/config/$hostname" || return
    cat "$barrkel/config/$hostname" |
        while read -r line; do
            maybe_echo_dir "$barrkel/base/$line"
        done
}

function gather_vars # args
{
    barrkel=$(cd "$(dirname $0)"; pwd)
    
    cd "$barrkel" || die "could not chdir to '$barrkel'"
    hostname=$(hostname)
    test -n "$hostname" || die "could not discover hostname"

    atoms=($(get_atom_dirs))
    
    while [ -n "$1" ]; do
        case "$1" in
            -q)
                no_prompt=1
                ;;
           	-f)
                force_ovewrite=1
                ;;
            -c)
                ignore_diff=1
                ;;

            *)
                usage
                ;;
        esac
        shift
    done

    cache="$barrkel/cache"
    staging="$barrkel/staging"
}

function ensure_mkdir # directory...
{
    local dir
    for dir; do
        test -d "$dir" && continue
        mkdir -p "$dir" || die "Could not create '$dir'"
        echo "Created '$dir'"
    done
}

function ensure_sanity
{
    test -f "$barrkel/config/$hostname" || die "Please create host config file '$barrkel/config/$hostname'"
    ensure_mkdir "$barrkel/host/$hostname/"{bin,home,home.d}

    rm -rf "$staging" || die "Couldn't remove '$staging'"
    ensure_mkdir "$staging"
}

function verify_no_change
{
    # Verify that nothing has changed
    test -d "$cache" || return
    
    cd "$cache" || die "Couldn't chdir to '$cache'"
    find -type f | while read -r line; do
        # don't mind if file is missing
        test -f "~/$line" || continue
        diff "$line" "~/$line" || (( ignore_diff)) || die "Exiting due to differences from cached config"
    done
}

function find_in_atom_dirs # relative-path
{
    get_atom_dirs | (
        while read -r line; do
            test -e "$line/$1" && {
                echo "$line/$1"
                exit
            }
        done
        exit 1
    ) && return
    die "couldn't find path '$1' in any atom directory"
}

function build_initial_profile
{
    local _path=$(find_in_atom_dirs bin/_path)
    printf "source '%s'\n" "$_path" > "$staging/.bash_profile"
    touch "$staging/.bashrc"
}

function force_copy_files # from-dir to-dir
{
    local from_dir="$1"
    local to_dir="$2"
    local f

    # copy all files and directories to target
    # merge directories, but overwrite existing files
    # depends on dotglob
    for f in "$from_dir"/*; do
        test -e "$f" || continue
        
        case "$f" in
            *~)
                continue
                ;;
            \#*#)
                continue
                ;;
        esac
        # -R: preserve pipes, don't read from them
        cp -f -R "$f" "$to_dir/"
    done
}

function copy_parts # from-dir to-dir
{
    local from_dir="$1"
    local to_dir="$2"
    local f
    local name
    
    for f in "$from_dir"/*; do
        name="${f##*/}"
        test -f "$f" && {
            # ultra-simple case: a single file, concatenate
            # be sure we have line endings though
            printf '\n' >> "to_dir/$name"
            cat "$f" >> "$to-dir/$name"
        }
    done
}

function echo_if_file_exists # filename...
{
    local arg
    for arg; do
        test -f "$arg" && echo "$arg"
        shift
    done
}

function list_all_part_files_for # dir
{
    local curr="$1"
    
    test -d "$curr/home.d" || return
    
    cd "$curr/home.d"
    for f in *; do
        if [ -f "$f" ]; then
            printf '%s\t%s\t%s\n' "50_$f" "$f" "$curr/home.d/$f"
        elif [ -d "$f" ]; then
            part_dir="$curr/home.d/$f"
            (
                cd "$f"
                
                for ff in *; do
                    test -f "$ff" || die "non-file found in part dir: $part_dir/$ff"
                    printf '%s\t%s\t%s\n' "$ff" "$f" "$part_dir/$ff"
                done
            ) || exit
        fi
    done
    
    test -f "$curr/profile" &&
        printf '%s\t%s\t%s\n' '++bash_profile' '.bash_profile' "$curr/.bash_profile"
        
    test -f "$curr/rc" &&
        printf '%s\t%s\n'     '++bashrc'       '.bashrc'       "$curr/.bashrc"
}

# output table of all parts for a given filename
# <part-filename> \t <target-filename> \t <path>
function list_all_part_files
{
    local atom

    list_all_part_files_for "$barrkel/host/$hostname"
    for atom in "${atoms[@]}"; do
        list_all_part_files_for "$barrkel/base/$atom"
    done
}

function add_chunk # source-file target-file
{
    echo "appending $1 to $2"
    case "$2" in
        */.bashrc | */.bash_profile)
            echo "# from $1" >> "$2"
            ;;
    esac
    cat "$1" >> "$2"
}

function build_staging
{
    build_initial_profile
    local atom
    
    for atom in "${atoms[@]}"; do
        # path
        test -d "$atom/bin" && echo "append_if_missing PATH $atom/bin" >> "$staging/.bash_profile"

        # files
        test -d "$atom/home" && force_copy_files "$atom/home" "$staging"
    done

    # parts
    (
        type add_chunk | tail -n +2
        list_all_part_files | sort | sed -r 's|(.*)\t(.*)\t(.*)|add_chunk "\3" "$staging/\2"|'
    ) | bash
    # list_all_part_files | sort | sed -r 's|(.*)\t(.*)\t(.*)|cat "\3" >> "$staging/\2"|' | bash
}

function apply_staging
{
    return
}

gather_vars "$@"

(( no_prompt )) || {
    echo "This will set up the barrkel home directory system using '$barrkel' as the barrkel home directory."
    echo "Press Enter to continue, or run this script as '$(basename $0) y' to avoid this prompt"
    read
}

ensure_sanity

verify_no_change

build_staging

apply_staging


